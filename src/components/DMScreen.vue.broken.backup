<template>
  <div
    class="relative min-h-screen overflow-hidden text-[color:var(--dh-panel-text)] transition-colors duration-500"
    :style="screenStyle"
  >
    <ScreenBackground :layers="backgroundLayers" :base-gradient="baseGradient" />
    <ScreenVideoBackground :src="youtubeBackgroundSrc" :muted="true" />

    <div class="relative flex min-h-screen flex-col gap-6 px-4 py-6 md:px-10 md:py-10">
      <div class="sticky top-4 z-10">
        <ScreenToolbar
          :dark-mode="themeClass === 'dark'"
          :sidebar-collapsed="sidebarCollapsed"
          :widgets-collapsed="widgetsCollapsed"
          :fear-value="fearLevel"
          @toggle:dark="toggleDarkMode"
          @toggle:sidebar="toggleSidebar"
          @toggle:widgets="toggleWidgets"
          @update:fear="setFearLevel"
        />
      </div>

      <div :class="gridClasses">
        <Transition
          enter-active-class="transition duration-400 transform"
          enter-from-class="-translate-x-4 opacity-0"
          enter-to-class="translate-x-0 opacity-100"
          leave-active-class="transition duration-300 transform"
          leave-from-class="translate-x-0 opacity-100"
          leave-to-class="-translate-x-4 opacity-0"
        >
          <ScreenSidebar
            v-if="!sidebarCollapsed"
            :size-options="sizeOptions"
            :next-widget-size="nextWidgetSize"
            :next-widget-size-label="nextWidgetSizeLabel"
            :widget-type-options="widgetTypeOptions"
            :next-widget-type="nextWidgetType"
            :widgets="widgets"
            :active-widget-id="activeWidgetId"
            :background-count="backgroundImages.length"
            :has-backgrounds="hasBackgrounds"
            @update:size="handleSizeSelect"
            @update:type="handleTypeSelect"
            @create:widget="addWidget"
            @clear-backgrounds="clearBackgrounds"
            @focus-widget="focusWidget"
          @upload-backgrounds="handleBackgroundUpload"
          />
        </Transition>

        <ScreenWorkspace
          :widgets="widgets"
          :active-widget-id="activeWidgetId"
          :size-options="sizeOptions"
          :span-class-for-size="widgetSpanClass"
          :collapsed="widgetsCollapsed"
          @toggle-edit="toggleEditing"
          @remove-widget="removeWidget"
          @update-widget="handleWidgetUpdate"
          @update-countdown="handleCountdownUpdate"
          @toggle-collapsed="toggleWidgets"
        />

        <!-- Minimized Dock -->
        <div
          v-if="minimizedWidgets.length"
          class="fixed bottom-4 right-4 z-20 flex max-w-[80vw] flex-wrap items-center gap-2 rounded-2xl border border-[color:var(--dh-panel-border)] bg-[var(--dh-panel-bg)]/90 p-2 shadow-xl backdrop-blur"
        >
          <button
            v-for="m in minimizedWidgets"
            :key="m.id"
            type="button"
            class="flex items-center gap-2 rounded-full border border-[color:var(--dh-panel-border)] bg-[var(--dh-panel-bg)] px-3 py-1.5 text-sm font-semibold text-[color:var(--dh-panel-text)] shadow-sm hover:-translate-y-0.5 hover:shadow focus:outline-none focus-visible:ring-2 focus-visible:ring-violet-300"
            @click="restoreWidget(m.id)"
          >
            <span class="text-base">{{ widgetIcon(m.type, m) }}</span>
            <span class="max-w-[40ch] truncate">{{ m.type === 'countdown' ? countdownDockLabel(m) : (m.title || dockLabel(m.type)) }}</span>
          </button>
        </div>
      </div>

      <ScreenFloatingControls
        :sidebar-collapsed="sidebarCollapsed"
        :widgets-collapsed="widgetsCollapsed"
        @toggle-sidebar="toggleSidebar"
        @toggle-widgets="toggleWidgets"
      />
    </div>
  </div>
</template>

<script lang="ts" setup>
import { computed, ref, nextTick } from 'vue'

import ScreenBackground from './dm-screen/ScreenBackground.vue'
import ScreenFloatingControls from './dm-screen/ScreenFloatingControls.vue'
import ScreenVideoBackground from './dm-screen/ScreenVideoBackground.vue'
import ScreenSidebar from './dm-screen/ScreenSidebar.vue'
import ScreenToolbar from './dm-screen/ScreenToolbar.vue'
import ScreenWorkspace from './dm-screen/ScreenWorkspace.vue'
import { useTheme } from '../composables/useTheme'
import { useFear } from '../composables/useFear'
import { useBackgrounds } from '../composables/useBackgrounds'
import { useWidgets } from '../composables/useWidgets'

// Orchestrate composables and children only

const { themeClass, toggleTheme } = useTheme()
const { fearLevel, setFearLevel } = useFear()
const {
  backgroundImages,
  activeBackgroundIndex,
  backgroundLayers,
  baseGradient,
  currentSlide,
  screenStyle,
  hasBackgrounds,
  handleBackgroundUpload,
  clearBackgrounds,
} = useBackgrounds()

const {
  widgets,
  sizeOptions,
  widgetTypeOptions,
  nextWidgetSize,
  nextWidgetSizeLabel,
  nextWidgetType,
  activeWidgetId,
  addWidget,
  toggleEditing,
  handleWidgetUpdate,
  handleCountdownUpdate,
  removeWidget,
  focusWidget,
  handleSizeSelect,
  handleTypeSelect,
  widgetSpanClass,
  minimizedWidgets,
  restoreWidget,
  dockLabel,
  widgetIcon,
  countdownDockLabel,
} = useWidgets()

const sidebarCollapsed = ref(false)
const widgetsCollapsed = ref(false)

  return {
    backgroundImage: `${gradient}, url('${slide.url}')`,
    backgroundSize: 'cover, cover',
    backgroundPosition: 'center, center',
    backgroundRepeat: 'no-repeat, no-repeat',
  }
})

import { computeYouTubeEmbed } from '../utils/embeds'
const youtubeBackgroundSrc = computed(() => {
  const yt = widgets.value.find((w) => (w as any).type === 'youtube' && (w as any).background && (w as any).url)
  if (!yt) return null as any
  const embed = computeYouTubeEmbed((yt as any).url)
  return embed || null
})
const gridClasses = computed(
  () =>
    [
      'grid gap-6 transition-all duration-500',
      sidebarCollapsed.value ? 'lg:grid-cols-1' : 'lg:grid-cols-[320px_minmax(0,1fr)]',
    ].join(' '),
)

const hasBackgrounds = computed(() => backgroundImages.value.length > 0)

const applyTheme = () => {
  if (typeof document === 'undefined') return
  document.documentElement.dataset.theme = darkMode.value ? 'dark' : 'light'

const clearFadeTimers = () => {
  if (typeof window === 'undefined') return
  fadeTimers.forEach((timer) => window.clearTimeout(timer))
  fadeTimers.clear()

const stopBackgroundTimer = () => {
  if (backgroundTimer !== null && typeof window !== 'undefined') {
    window.clearInterval(backgroundTimer)
    backgroundTimer = null
  }

const startBackgroundTimer = () => {
  stopBackgroundTimer()
  if (typeof window === 'undefined') return
  if (backgroundImages.value.length <= 1) return

  backgroundTimer = window.setInterval(() => {
    activeBackgroundIndex.value =
      (activeBackgroundIndex.value + 1) % backgroundImages.value.length
  }, 12000)

const handleBackgroundUpload = (files: File[]) => {
  if (!files.length) return

  const nextSlides = files.map((file) => ({
    id: createBackgroundId(),
    url: URL.createObjectURL(file),
  }))

  backgroundImages.value = [...nextSlides, ...backgroundImages.value]
  activeBackgroundIndex.value = 0
  startBackgroundTimer()

const clearBackgrounds = () => {
  backgroundImages.value.forEach((slide) => URL.revokeObjectURL(slide.url))
  backgroundImages.value = []
  activeBackgroundIndex.value = 0
  stopBackgroundTimer()
  clearFadeTimers()
  backgroundLayers.value = []

const setFearLevel = (value: number) => {
  const next = Math.max(0, Math.min(12, value))
  fearLevel.value = next

const addWidget = () => {
  const type = nextWidgetType.value
  let widget: DashboardWidget

  if (type === 'countdown') {
    const config = createDefaultCountdownConfig()
    widget = {
      id: createId(),
      title: resolveCountdownTitle(config),
      description: resolveCountdownDescription(config),
      size: nextWidgetSize.value,
      editing: true,
      type: 'countdown',
      countdown: config,
    }
  } else if (type === 'youtube') {
    widget = {
      id: createId(),
      title: 'YouTube',
      url: '',
      size: nextWidgetSize.value,
      editing: true,
      type: 'youtube',
      background: false,
      hidden: false,
    }
  } else if (type === 'spotify') {
    widget = {
      id: createId(),
      title: 'Spotify',
      url: '',
      size: nextWidgetSize.value,
      editing: true,
      type: 'spotify',
      hidden: false,
    }
  } else {
    widget = {
      id: createId(),
      title: '',
      body: '',
      size: nextWidgetSize.value,
      editing: true,
      type: 'note',
      hidden: false,
    }
  }

  widgets.value = [widget, ...widgets.value]
  activeWidgetId.value = widget.id

  nextTick(() => {
    if (typeof window === 'undefined') return
    if (widget.type === 'note') {
      const firstInput = window.document.querySelector<HTMLInputElement>(`#${widget.id}-title`)
      firstInput?.focus()
    }
  })

const toggleEditing = (id: string) => {
  const widget = widgets.value.find((entry) => entry.id === id)
  if (!widget) return
  widget.editing = !widget.editing
  activeWidgetId.value = id
  if (widget.editing) {
    nextTick(() => {
      if (typeof window === 'undefined') return
      if (widget.type === 'note') {
        const input = window.document.querySelector<HTMLInputElement>(`#${id}-title`)
        input?.focus()
      }
    })
  }

const handleWidgetUpdate = (payload: { id: string; key: 'title' | 'body' | 'size' | 'url' | 'background' | 'hidden'; value: string | boolean }) => {
  const widget = widgets.value.find((entry) => entry.id === payload.id)
  if (!widget) return
  if (payload.key === 'size') {
    widget.size = payload.value as WidgetSize
    return
  }
  if (widget.type === 'note') {
    if (payload.key === 'title') widget.title = payload.value as string
    else if (payload.key === 'body') widget.body = payload.value as string
    else if (payload.key === 'hidden') (widget as any).hidden = Boolean(payload.value)
    return
  }
  if (widget.type === 'youtube') {
    if (payload.key === 'title') widget.title = payload.value as string
    else if (payload.key === 'url') widget.url = payload.value as string
    else if (payload.key === 'background') {
      const next = Boolean(payload.value)
      // Enforce single background: clear others if enabling
      if (next) {
        widgets.value = widgets.value.map((w) =>
          w.type === 'youtube' ? { ...w, background: w.id === widget.id } : w,
        ) as any
      } else {
        widget.background = false
      }
    }
    else if (payload.key === 'hidden') (widget as any).hidden = Boolean(payload.value)
    return
  }
  if (widget.type === 'spotify') {
    if (payload.key === 'title') widget.title = payload.value as string
    else if (payload.key === 'url') widget.url = payload.value as string
    else if (payload.key === 'hidden') (widget as any).hidden = Boolean(payload.value)
    return
  }
  if (widget.type === 'countdown') {
    if (payload.key === 'title') widget.title = payload.value as string
    else if (payload.key === 'hidden') (widget as any).hidden = Boolean(payload.value)
    return
  }

const removeWidget = (id: string) => {
  widgets.value = widgets.value.filter((widget) => widget.id !== id)
  if (activeWidgetId.value === id) {
    activeWidgetId.value = widgets.value[0]?.id ?? null
  }

const focusWidget = (id: string) => {
  activeWidgetId.value = id
  const widget = widgets.value.find((entry) => entry.id === id)
  if (!widget) return
  if (!widget.editing) {
    widget.editing = true
  }
  nextTick(() => {
    if (typeof window === 'undefined') return
    if (widget.type === 'note') {
      const input = window.document.querySelector<HTMLInputElement>(`#${id}-title`)
      input?.focus()
    }
  })

const toggleDarkMode = () => {
  toggleTheme()

const toggleSidebar = () => {
  sidebarCollapsed.value = !sidebarCollapsed.value

const toggleWidgets = () => {
  widgetsCollapsed.value = !widgetsCollapsed.value

const handleSizeSelect = (size: WidgetSize) => {
  nextWidgetSize.value = size

const handleTypeSelect = (type: DashboardWidget['type']) => {
  nextWidgetType.value = type

const restoreWidget = (id: string) => {
  const w = widgets.value.find((x) => x.id === id)
  if (!w) return
  ;(w as any).hidden = false
  activeWidgetId.value = id

const dockLabel = (type: DashboardWidget['type']) => {
  switch (type) {
    case 'note':
      return 'Note'
    case 'countdown':
      return 'Countdown'
    case 'youtube':
      return 'YouTube'
    case 'spotify':
      return 'Spotify'
    default:
      return 'Widget'
  }

const widgetIcon = (type: DashboardWidget['type'], w?: DashboardWidget) => {
  switch (type) {
    case 'note':
      return '??'
    case 'countdown':
      return '??'
    case 'youtube':
      return '??'
    case 'spotify':
      return '??'
    default:
      return '??'
  }

const countdownDockLabel = (w: DashboardWidget) => {
  if (w.type !== 'countdown') return w.title || 'Countdown'
  const steps = (w as any).countdown?.steps ?? []
  const current = steps.filter((s: any) => s.active).length
  const total = steps.length || 0
  return `${w.title || 'Countdown'} (${current}/${total})`

const handleCountdownUpdate = (
  payload: { id: string; config: CountdownConfig; title: string; description: string },
) => {
  const widget = widgets.value.find((entry) => entry.id === payload.id)
  if (!widget || widget.type !== 'countdown') return
  widget.countdown = payload.config
  widget.title = payload.title.trim() || defaultTitle
  widget.description = payload.description.trim()

const sizeLabel = (size: WidgetSize) => {
  const match = sizeOptions.find((option) => option.value === size)
  return match ? match.label : size

const { fearLevel, setFearLevel } = useFear()











